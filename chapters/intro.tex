\chapter{Introduction} \label{ch:intro}

\glsreset{RV}
\glsreset{SERE}

\emph{Reactive systems}~\cite{harel1984reactive} are those systems
which operate continuously while responding to any input that it might
receive from its environment.
The input that goes into such a system and the output that it produces both
constitute infinite streams of values.
% Air conditioning systems (AC), toll gates for road traffic, operating
% systems, autopilot systems in aircraft etc are all examples of
% reactive systems.
Air-conditioners, autopilot systems in aircraft, self-driving cars,
railway signaling systems, etc. are all examples of reactive systems.
Notice that the latter examples are used in applications where safety
is of utmost importance~\cite{baker2019timeline}.
Such systems are known as \emph{safety-critical systems}.
These systems are used in applications where errors can be
expensive not only in terms of money~\cite{pentium1995anatomy} and
effort~\cite{mcquaid2012software}, but also human
lives~\cite{arianeV1997analysis,gulf1992patriot}.
Hence, it is desirable to have a high level of confidence in the
correctness of such systems.

% Running example
% The notion of correctness for a reactive system depends on the purpose
% of that system.
A system is considered correct if it always behaves as we expect it
to behave.
One way to express the correctness of reactive systems is by encoding
it as a relation between the system's input and output.
For example, consider an air-conditioning system
% \footnote{\href{https://nypost.com/2023/06/25/annoyed-janitor-turns-off-super-cold-freezer-and-destroys-decades-of-scientific-work-causes-at-least-1m-in-damages/}%
% {https://nypost.com/2023/06/25/annoyed-janitor-turns-off-super-cold-freezer-and-destroys-\-decades-of-scientific-work-causes-at-least-1m-in-damages/}%
% }
which is supposed to maintain the temperature within a certain
range~\cite{janitor2023rv}.
When set to a particular temperature $T$, a correctly behaving
air-conditioner would ensure that the temperature is always within
$T±δ$ where $δ$ is a tolerance value.
The input to the system is the current temperature, and its output is
the action that it takes to regulate the temperature.
The air-conditioner should cool its surroundings when temperature goes above
$T+δ$, induce heating if it goes below $T-δ$, and remain idle if the
temperature is within permitted limits.
Notice that in this example, both the input and output varies with
time. This is a hallmark of reactive systems.

% %
% For example, consider the controller of an \gls{AC} system.
% %
% The \gls{AC} is supposed to maintain the temperature within a certain
% range.
% %
% The controller is expected to generate a signal instructing the system
% to trigger adjustments required to maintain the temperature within the
% desired levels.
% %
% As far as the controller is concerned, the input is the current
% temperature sensed by the \gls{AC} system and the output is the signal
% that the controller generates to instruct the \gls{AC} to regulate the
% temperature if needed.
% %
% % The input is the current temperature and the output is the signal
% % generated by the controller to regulate the temperature.
% %
% Suppose the controller is expected to ensure that the \gls{AC}
% maintains the temperature at (25±δ)℃ where δ is a tolerance value,
% % In a scenario where the controller is expected to maintain the
% % temperature at \SI{25}{\celsius} with a tolerance value of δ,
% A correctly behaving controller would generate a signal to instruct
% the \gls{AC} to cause temperature change with respect to the set
% temperature.
% The controller could send a \code{COOL} instruction to cause cooling
% if the temperature goes beyond (25+δ)℃,
% a \code{HEAT} instruction to induce heating if it drops below (25-δ)℃,
% and an instruction \code{HOLD} to maintain the status quo.
% % This signal could be having a value \code{HEAT} to cause heating,
% % \code{COOL} for cooling and \code{HOLD} for status quo.
% % \SI[parse-numbers=false]{(25+\delta)}{\celsius} or heating if it drops
% % below \SI[parse-numbers=false]{(25-\delta)}{\celsius}.
% %
% % Note that in this case, we are talking about the correctness of the
% % controller that drives the AC. Not the AC itself.
% % The AC can still fail to work properly if it does not respond to the
% % controller's command.
% %
% Observe that we used a relation between the input (current temperature
% as reported by a sensor) and the output (actual temperature) to
% indicate the correctness of the controller.
% Similarly, the expected behaviour or the correctness of a reactive
% system can be expressed as a relation between its input and output.
%
% Notice that in the above example, both the input and output varies
% with time. This is a hallmark of reactive systems.

% Testing and its inadequacy
% Having established a way to express system correctness, we need a way
% to ensure correctness.
One way to improve confidence in the correctness of systems is
\emph{testing}.
% Yet the effectiveness of testing depends on the quality test cases
% involved.
However, a comprehensive set of test cases that exhaustively covers
all possible states of the system is rarely achievable.
In practice, test cases are usually incorporated by the designers
during the system development phase, with new test cases added as and
when new bugs are discovered.
% It is easy to miss corner cases or scenarios that the designers had
% not yet considered in such a set up.
Though useful for detecting presence of bugs, testing is not capable
of demonstrating the absence of bugs~\cite{DijkstraTesting}.
We need a better way to demonstrate correctness of systems.
In other words, we need \emph{formal verification}.
   
% Formal verification
Formal verification is a class of rigorous and precise techniques for
proving system correctness.
The system correctness is expressed as a specification in an
appropriate logic.
The system is correct only if it conforms with the specification in
all possible scenarios.
Such specifications are usually meant to be machine checked, and
can offer comprehensive coverage of the design.
% This specification is then compared against a formal model of the
% system.
% Such a conformance check is done by validating the model against its
% specification by following the well-defined rules of the logic in
% which the specification was defined.
% Thus, unlike testing, formal verification is capable of even proving
% absence of errors as it exhaustively checks all scenarios relevant to
% the specification.
% Instead of manually figuring out use cases susceptible to trigger bugs
% randomly, formal verification can help find mistakes in a
% systematic and principled manner.

In many applications, the input and output is the only system
information available.
% one should assume that the internal details of the system are
% unavailable.
This may be due to the design of the system being proprietary or it
being derived using machine learning techniques.
The system under consideration may even be natural phenomenon, like in
the case of tsunami warning systems.
%
In such cases, the system is a black-box and only its input-output
behaviour can be studied.
Considering these limitations, \gls{RV} is often employed to attain
some level of confidence with regard to the correctness of such
systems.
\gls{RV} is a dynamic form of formal verification that verifies system
correctness.
% It observes the input and output of the \gls{SuV} to ensure that it is
% behaving as desired by 
It employs an auxiliary system called \emph{monitor}, which constantly
observes the input and output of the \gls{SuV}.
The monitor verifies that the system correctness specification, which
is expressed as an input-output relation, is not violated at any
execution step of the \gls{SuV}.
Deviations of the system from desired behaviour may cause the monitor
to trigger a signal, which in turn may induce corrective measures.
% The desired behaviour of the system can 
%
% An opaque system's observable behaviour consists of the data that goes
% into the system and the output that the system produces as response.
% Desired behaviour or correctness of this kind of systems can be
% expressed as a relation between their input and output.
% This can be done by expressing desired system behaviour as an
% input-output relation.
%
% For instance, if internal details of the system are unavailable in the
% example of an \gls{AC} system that we saw earlier, all we can use to
% reason about that system is its observable behaviour.
% Being a reactive system, correct system behaviour can be expressed as
% an input-output relation and the system behaviour itself can be
% monitored to check for deviations from desired behaviour.
% In the case of the \gls{AC} example, we could have a monitor to check
% whether the \gls{AC} is doing its job properly while it is operating.
% This monitor will trigger a signal when it detects any deviation from
% desired behaviour of the system.
% The signal so generated may be made as an instruction for the \gls{AC}
% to take corrective measures or may be an alert for a human to
% intervene.
% This way of employing a monitor to ensure system correctness while the
% system is running is the essence of a formal verification technique
% called \emph{\gls{RV}}.
%
% the current temperature going as input and the change in temperature
% produced by the \gls{AC} is all we can use to reason about the system
% if its internal details are not available.
% In such a situation, system correctness can be expressed as a relation
% between its input and output. ie, its behaviour.
% The system can be monitored to check whether 
% %
% correctness can be expressed as a relation between the current room
% temperature and triggering of the signals to adjust the temperature.
% Although there are limitations in expressing system correctness in
% this manner, it is the best that we can attain in scenarios where
% system internals cannot be relied upon to express desired behaviour.
% % %
% % Note that in the case, we are talking about the correctness of the
% % controller that drives the AC. Not the AC itself.
% % The AC can still fail to work properly if it does not respond to the
% % controller's command.
%
%
% Recall that we saw how correctness of reactive systems can be
% expressed as an input-output relation.
% In the absence of access to internal working of the system, we can
% only observe the system as it runs to verify that the input-output
% relation specification holds at each operation step.
% \emph{\Gls{RV}} is a formal verification technique that does exactly
% this.
% In \gls{RV}, the system correctness is expressed as a formal
% definition in terms of its observable behaviour.
% The actual behaviour of the system is constantly observed by an entity
% called \emph{monitor}, which checks whether the system is indeed
% conforming to the behaviour expressed by the specification.
Instead of verifying all possible executions of the system, \gls{RV}
dynamically verifies its current execution.
The monitor can be made to trigger corrective actions upon any
deviation from desired behaviour.
% Thus, \gls{RV} is suited for ensuring correctness of reactive systems.
In short, \gls{RV} consists of two components:
\begin{enumerate}
\item Formal definition $φ$ of correct system behaviour, which is usually
  an input-output relation.
\item An auxiliary system called monitor, which verifies that the
  \gls{SuV} adheres to $φ$ 
\end{enumerate}

\gls{RV} entrusts the task of verifying the runtime behaviour of the
\gls{SuV} to the monitor, which itself is a reactive system.
% However, the monitor itself is a reactive system and errors can creep into
% its design as well.
Since the safety of the overall system being verified with \gls{RV}
depends on the correctness of the monitor, we need some guarantee of
its correctness.
Unlike \gls{SuV} whose internals details may not be accessible,
monitors in \gls{RV} are something that we ourselves design with its
internals being available for us to examine.
Thus, we can hope to prove correctness of the monitors completely.

% Though monitors of \gls{RV} are usually less complex than the systems
% that they monitor, confidence of the correctness of the verification
% process can be enhanced if the correctness of monitors themselves
% could in some way be guaranteed.
% Work done for this thesis is a step towards achieving that.

% \begin{objective}
% Trustable monitors for \gls{RV}.
% \end{objective}

Correctness of the reactive system being observed by the monitor in
\gls{RV} is expressed by a formal specification, which is usually a
relation between the input and output the \gls{SuV} using an
appropriate logic.
%
Since the working of reactive systems in general and monitors of
\gls{RV} in particular varies with time, \emph{temporal logics} are a
natural fit to express the correctness specification of monitors.
% Since input and output of reactive systems are time varying
% quantities, we need a \emph{temporal logic}, which are logics that
% captures the notion of time.
% \emph{Temporal logics} are suited for such specifications
% as the correctness is expressed by means of an input-output relation
% that varies with time.


The monitor involved in \gls{RV} is essentially a language acceptor.
It can be thought of as an automaton accepting only the prefixes of
input-output streams corresponding to correct behaviour.
i.e., string matching is useful in \gls{RV}.
This motivates our decision to study the problem of regular expression
matching.
%
\gls{PSL} is a specification language based on a temporal logic that
is commonly used for encoding correctness specifications of hardware.
A prominent feature of properties written in \gls{PSL} is the ability
to use a generalized form of regular expressions to express occurrence of
events.
Thus, monitors designed to verify conformance to \gls{PSL} properties
must also be able to do regular expression matching.
%
Our work can be seen as a first step towards building \gls{PSL}
monitors in hardware.
% The main goal of this thesis to produce regular expression
% matchers which can be used to build certifiably correct checkers for \gls{PSL}
% specifications.
Hardware implementations of \gls{rgx} matchers is more desirable over
software implementation due to the former's ability to operate at
higher speeds.
We chose Coq~\cite{cpdt} to implement the core component of our work
to allow for the possibility of verifying the correctness of the
monitors.

\begin{objective}
Generation of matchers capable of checking whether a given string
matches a regular expression, with provision to reason about
correctness of output design.
\end{objective}

Regular expressions are used in a wide variety of domains in addition
to their use in \gls{PSL}, ranging from text processing to
computational biology~\cite{stephens2005oracle}.
A verified regular expression matcher can be useful in such
applications as well.
Many of these applications, including \gls{RV}, sometimes require
matching to be done at rates faster than what software implementations
of matchers are capable of.
Hence, hardware implementations of matchers which are generally faster
than their software counterparts, are desirable.
% Hardware implementations of regular expression matchers are generally
% capable of running at rates faster than software.
% Such implementations are often run on \glspl{FPGA}.
Formal verification is especially relevant in hardware designs
because bugs in hardware are difficult or even impossible to fix once
deployed when compared to software.
This makes verification more relevant in the case of hardware designs.

This thesis is a step towards generation of hardware implementation of
formally certified-correct regular expression matchers.
We present a workflow to generate the hardware implementation of a
matcher capable of recognizing the language corresponding to a given
regular expression.
This flow consists of the following steps:

\begin{itemize}
\item
  Encoding of regular expressions as values in the Coq theorem prover.
  Automata of a corresponding matcher is generated within Coq via a 
  translation procedure defined in our library.
  The regex and its matcher NFA are built within Coq to leave open the
  possibility of proving the correctness of the translation procedure.
\item 
  Coq's extraction mechanism converts the automata of the matcher into
  Haskell code.
  We do this to take advantage of the ability of the compiler of a
  high level \gls{HDL} named Clash, which is capable of converting
  a subset of Haskell to equivalent Verilog description.
  We engineer our Coq formalization in such a way that the extracted
  Haskell falls within this subset.
  This overcomes the difficulty of converting Coq code into \gls{HDL}.
\item 
  The Verilog design obtained from the Clash compiler is synthesized
  using \gls{EDA} tools to produce an \gls{FPGA} loadable bitstream.
\end{itemize}

% This model is then extracted to Haskell which is then used to build a
% design of the matcher in Clash, a Haskell-like \gls{HDL}.
% Clash compiler is used produce equivalent verilog, which is finally
% synthesized using \gls{EDA} tools to produce bitstream that can be
% loaded onto an \gls{FPGA}.

% We use Coq to encode regular expression and for generating matcher
% designs to leave open the possibility of proving their correctness
% within the theorem prover.
% Once the design has been generate within Coq, we need a way to convert
% it into an equivalent hardware design. 
% Hardware designs are usually descriptions written in a \gls{HDL}.
% Verilog and VHDL are the most commonly used \glspl{HDL}.
% Definitions made in Coq can be extracted as programs in other
% programming languages like OCaml and Haskell.
% Coq does not offer such an extraction procedure to an \gls{HDL} by
% default.
% Still we can take advantage of its ability to extract to Haskell to
% eventually produce an \gls{HDL} design. 
% This is done by using Clash, whose syntax very closely resembles that
% of Haskell with its compiler capable of converting Clash designs to
% equivalent Verilog or VHDL.
% Finally, synthesis tools are used to produce the \gls{FPGA} bitstream.

The remainder of this thesis is organized as follows:
Chapter~\ref{ch:prelims} contains background information that are referenced in
later chapters.
We detail how we accept an input regex and generate an automaton model
of its matcher in Chapter~\ref{ch:method}.
Afterwards, Chapter~\ref{ch:hdlgen} explains how the automata model is converted
to a concrete hardware implementation with the help of Clash.
In Chapter~\ref{ch:outcome}, we analyse and comment on the results of
our flow before concluding with Chapter~\ref{ch:bye} where we mention
possible directions which may be explored to extend this work.

% An aspect that is common to both model checking and theorem proving is
% the assumption that a model of the system with knowledge of its
% internal working is available.
% ie, the system is assumed to be a white box.
% Yet, this requirement is not always feasible to satisfy.
% Design may be proprietary or may have been derived using machine
% learning techniques. System may even be natural phenomenon, like in
% the case of tsunami warning systems.
% Also worth remembering is that legacy systems which were designed
% without thought for verification will not even have a formal model to
% verify against.
% Furthermore, even after a system design is verified correct, errors
% might still creep in its implementation.
% For example in the case of hardware, fabrication flaws can introduce
% new errors, which is why post-silicon validation is relevant for
% hardware chips~\cite{mishra2019post}.

% Even in the absence of a model with knowledge of the internal working
% of the \SuV, there is still one thing that we can use to reason about
% that system: its observable behaviour.
% The data going as input into the system and the output generated by
% the system in response to it are still visible to us.
% We can define the correctness of the system as a specification in
% terms of this input and output and verify that the system always
% behaves as per this specification.
% An external monitor can be made to constantly observe the behaviour of
% the \SuV while it works.
% Such a monitor will check for conformance to correctness specification
% at each operation step of the \SuV.
% This is a form of formal verification called \emph{\RV}.
% Unlike model checking and theorem proving where verification is
% performed statically before the system is deployed, runtime
% verification is done dynamically while the \SuV is actually running.
% The monitor is an entity distinct from the \SuV.

% \RV entrusts the monitor with verifying that the behaviour of the \SuV
% is in conformance with its specification. Yet the monitor itself is a
% system.
% Though monitors are usually less complex than the system that they
% monitor, and hence have less avenues for bugs, it is desirable to
% enhance trust in the system being verified with \RV by having a
% certain measure of confidence in the correctness of the monitor as
% well.
% The work done as part of this thesis is a step towards building
% formally verified monitors for runtime verification.

% Specifications for \RV must be written in formal language.
% Languages based on temporal logic are suited for \RV since the monitor
% needs to check conformance of system behaviour at each operation step
% of the \SuV.
% \PSL is such a language that is popular in the verification of
% hardware.  One of the features of this language is its use of \SERE,
% which are a form of regular expressions where the atoms are boolean
% tests on the input.
% Properties written in \PSL language can be written in two forms:
% LTL-style and SERE-style.
% Though LTL-style \PSL properties need not involve any use of \SERE,
% those made using \SERE are often convenient for industry users who
% usually are not comfortable encoding specifications in LTL.
% Properties written in this language can be written in two forms:
% LTL-style and SERE-style.

% Since \SERE are part of \PSL, an effort to formalize PSL necessarily
% entails a need for a formalization of \SERE.
% In this thesis, we formalize a subset of \SERE that we call \rgx.  The
% name 'Tests-as-atoms' was chosen because like \SERE, that atoms of
% these regex are boolean tests on input alphabet.
% We present a fully automatic flow by which a hardware implementation
% of a matcher capable of recognizing the language corresponding to a
% given \rgx can be generated.
% We encode regex as values inside the Coq proof assistant from which a
% model of the corresponding matcher is derived.
% This model is then extracted to Haskell which is then used to build a
% design of the matcher in Clash, a Haskell-like HDL.
% Clash compiler is used produce equivalent verilog, which is finally
% synthesized using a \gls{EDA} tools to produce bitstream that can be
% loaded onto an \gls{FPGA}.

% ppk 17-Dec-2024
% - Forward ref to reglang, regex
% - Outline
% - Why hardware impl
% - Why clash extraction
% - What you do


%% \section{Related works}
%% Many algorithms are known for regex to \gls{NFA} conversion.
%% Prominent among them is McNaughton-Yamada-Thompson algorithm, also
%% known as Thompson construction~\cite{thompson1968nfa}.
%% % which simulates \gls{NFA} instead of directly converting .
%% With regard to hardware implementations of \gls{rgx} matchers,
%% automata processor~\cite{micron2014AP} is a domain specific
%% architecture for running \glspl{NFA}.
