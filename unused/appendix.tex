\renewcommand{\thechapter}{A}
\section{eDSL for encoding regex} \label{code:edsl-combinators}
The \gls{rgx} that serves as the input to our flow is a Coq term of
type $re\ (\Sigma \to \mathbb{B})$.
These terms are verbose and not easy to get right without a certain
level of familiarity with Coq and the types itself.
In order to make it more convenient to enter the input \gls{rgx}, we
have made an \gls{eDSL} by taking advantage of the notations feature
that allows us to customize the Coq parser.
A few of the constructs of this \gls{eDSL} was presented in
Table~\ref{tab:edsl-constructors}.
The remaining constructs are shown in Table~\ref{tab:edsl}.

\begin{figure}[h]
  \begin{minipage}{0.5\textwidth}%
    \begin{subfigure}{\linewidth}
      \begin{mathpar}
        \begin{array}{ll}
          \toprule
          \text{eDSL} & \text{Meaning}               \\
          \midrule
          T           & \text{Boolean value $true$}  \\
          F           & \text{Boolean value $false$} \\
          \bottomrule
        \end{array}
      \end{mathpar}
      \label{tab:edsl-bool}
      \caption{Boolean-specific}
    \end{subfigure}%
  \end{minipage}%
  \hfill%
  \begin{subfigure}[c]{0.5\linewidth}
    \centering
    \begin{mathpar}
      \begin{array}{ll}
        \toprule
        \text{eDSL}                 & \text{Meaning}                        \\
        \midrule
        @c                          & \text{Character $c$}                  \\
        \cdot                       & \text{Any character}                  \\
        \text{$\textbackslash x$ n} & \text{Character with ASCII value $n$} \\
        \textbackslash w            & \text{Word character}                 \\
        \textbackslash W            & \text{Non-word character}             \\
        \textbackslash s            & \text{Whitespace character}           \\
        \textbackslash S            & \text{Non-whitespace character}       \\
        \textbackslash d            & \text{Digit character}                \\
        \textbackslash D            & \text{Non-digit character}            \\
        \bottomrule
      \end{array}
    \end{mathpar}
    \caption{Character-specific}
    \label{tab:edsl-char}
  \end{subfigure}
  \caption{Syntax of eDSL for input regex}
  \label{tab:edsl}
\end{figure}


\section{Classic regex}
\label{fig:re}

Syntax of classic regex:
% \label{gram:re-syntax}

\begin{mathpar}%\scriptsize
\begin{array}{rcll}
r        & :=    & \emptyset   & \text{(Empty language)}     \\
         & \Big| & \varepsilon & \text{(Empty string)}       \\
         & \Big| & c           & \text{(Character as atom)}  \\ 
         & \Big| & r_1;r_2     & \text{(Concatenation)}      \\ 
         & \Big| & r_1|r_2     & \text{(Choice)}             \\ 
         & \Big| & r^*         & \text{(Zero or more match)} \\
\end{array}
\end{mathpar}

Language associated with classic regex: 
% \label{gram:re-lang}

\begin{mathpar}
\begin{array}{rcl}
L(∅)     & =     & \{\}                                      \\
L(ε)     & =     & \{""\}                                    \\
L(a)     & =     & \{a\}                                     \\
L(r₁;r₂) & =     & \{w₁ w₂ \mid w₁ ∈ L(r₁), w₂ ∈ L(r₂)\}     \\
L(r₁|r₂) & =     & \{w \mid w ∈ L(r₁) ∨ w ∈ L(r₂)\}          \\
L(r*)    & =     & \{w \mid w ∈ L(r;r*) ∨ w ∈ L(ε)\}         \\
\end{array}
\end{mathpar}

Semantics of classic regex:

% \label{gram:re-sem}

\begin{mathpar}
  \inferrule*[right=SEps]
    { }
    {[] \models \varepsilon}

  \inferrule*[right=SAtom]
    {a: T \\ c: T \\ c = a}
    {[c] \models Atom \ a}

  \inferrule*[right=SCat]
    {w_1 \models r_1 \\ w_2 \models r_2}
    {w_1 w_2 \models r_1;r_2}

  \inferrule*[right=SAltL]
    {w \models r_1}
    {w \models r_1|r_2}

  \inferrule*[right=SAltR]
    {w \models r_2}
    {w \models r_1|r_2}

  \inferrule*[right=SStarD]
    {w \models \varepsilon}
    {w \models r*}

  \inferrule*[right=SStarM]
    {w_1 \models r \\ w_2 \models r*}
    {w_1 w_2 \models r*}
\end{mathpar}

\section{A complete Clash design}
The Coq program, extracted Haskell code, Clash design built using this haskell
code and the resultant Verilog code for the \gls{rgx} $\lambda x.\ x==True$ is
shown in this section.

\subsection{Coq program}
Coq file used to generate matcher for the input \gls{rgx}.

\input{chapters/snippets/complete-coq-eg.tex}

\subsection{Extracted Haskell}
\gls{NFA} information extracted out of Coq as Haskell.

\input{chapters/snippets/complete-hsk-extr-eg.tex}

\subsection{Clash design}
Clash design built from the Haskell code extracted out of Coq.
% by our flow for the regex \code{re.Atom
% (Bool.eqb true)}.

\input{chapters/snippets/complete-clash-eg.tex}

\subsection{Resultant Verilog}
Verilog code generated by the Clash compiler using our Clash design.

\input{chapters/snippets/complete-verilog-eg.tex}
